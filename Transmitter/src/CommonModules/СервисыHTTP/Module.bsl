// @strict-types

#Область ПрограммныйИнтерфейс

// КодыСостояния возвращает менеджер модуля см. КодыСостоянияHTTPКлиентСерверПовтИсп.
// 
// Возвращаемое значение:
// 	ОбщийМодуль - менеджер модуля см. КодыСостоянияHTTPКлиентСерверПовтИсп;
//
Функция КодыСостояния() Экспорт
	
	Возврат КодыСостоянияHTTPКлиентСерверПовтИсп;
	
КонецФункции

// СоздатьОтвет по коду состояния создает ответ HTTP-сервиса согласно спецификации api: смотри "./api/transmitter.yml".
// 
// Параметры:
//  КодСостояния - Число - код состояния создаваемого ответа;
//  Сообщение - Неопределено, Строка - текст сообщения;
// 
// Возвращаемое значение:
//  HTTPСервисОтвет - ответ HTTP-сервиса;
//
Функция СоздатьОтвет( Знач КодСостояния, Знач Сообщение = Неопределено ) Экспорт
	
	Результат = Неопределено;
	
	Если ( КодыСостояния().IsBadRequest(КодСостояния) ) Тогда
		
		Результат = НоваяОшибкаНеправильныйЗапрос( Сообщение );
		
	ИначеЕсли ( КодыСостояния().IsLocked(КодСостояния) ) Тогда
		
		Результат = НоваяОшибкаЗаблокировано( Сообщение );
		
	ИначеЕсли ( КодыСостояния().IsInternalServerError(КодСостояния) ) Тогда
		
		Результат = НоваяОшибкаСервера( Сообщение );
		
	Иначе
		
		Результат = ОтветБезСообщения( КодСостояния ) ;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// СоздатьОтветВФорматеJSON создает ответ HTTP-сервиса в формате JSON,
// устанавливая тело ответа из переданных данных.
// 
// Параметры:
// 	Данные - Структура - данные;
// 	
// Возвращаемое значение:
// 	HTTPСервисОтвет - ответ HTTP-сервиса;
//
Функция СоздатьОтветВФорматеJSON( Знач Данные ) Экспорт
	
	Ответ = Новый HTTPСервисОтвет( КодыСостояния().НайтиКодПоИдентификатору("OK") );
	УстановитьТипКонтента( Ответ, "application/json" );
	УстановитьТелоИзСтрокиJSON( Ответ, Данные );
	
	Возврат Ответ;
	
КонецФункции

// НайтиЗаголовок возвращает результат поиска заголовка по ключу. Метод ищет заголовок по ключу в исходном регистре.
// Если заголовок не найден, выполняется поиск с ключом в нижнем регистре, затем - в верхнем.
// Используется для заголовоков. Используется для решения проблемы с клиентами, которые преобразуют заголовки
// в верхний или нижний регистр.
// 
// Параметры:
// 	Запрос - HTTPСервисЗапрос - HTTP-запрос;
// 	Ключ - Строка - ключ;
// 	
// Возвращаемое значение:
//	- Неопределено - заголовок не найден;
//	- Произвольный - значение найденного заголовка;
// 	
Функция НайтиЗаголовок( Знач Запрос, Знач Ключ ) Экспорт
	
	Результат = Запрос.Заголовки.Получить( Ключ ); // Неопределено, Произвольный

	Если ( Результат = Неопределено ) Тогда
		
		Результат = Запрос.Заголовки.Получить( НРег(Ключ) );
		
	КонецЕсли;
	
	Если ( Результат = Неопределено ) Тогда
		
		Результат = Запрос.Заголовки.Получить( ВРег(Ключ) );
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Область Ошибки

// ПолучитьСхемуСообщения возвращает схему сообщения об ошибке согласно спецификации api:
// смотри "./api/transmitter.yml" -> components: schemas: message.
// 
// Параметры:
// 	Сообщение - Неопределено, Строка - текст ошибки;
// 	
// Возвращаемое значение:
// 	Структура - схема сообщения:
// 	* message - Неопределено, Строка - текст сообщения;
//
Функция ПолучитьСхемуСообщения( Знач Сообщение ) Экспорт
	
	Результат = Новый Структура();
	Результат.Вставить( "message", Сообщение );
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти





// GetMultipartMessageByType returns message parts separated by data type.
// If the types match, the last one is taken.
// 
// Parameters:
// 	Request - HTTPServiceRequest - HTTP request;
// 	
// Returns:
//	- Undefined - bad request;
//	- Map - context by type:
//		* Key - String - type;
//		* Value - Arbitrary - context;
//
Function GetMultipartMessageByType( Request ) Export
	
	Boundary = FindBoundary( Request );
	
	If ( Boundary = Undefined ) Then
		
		Return Undefined;
		
	EndIf;

	Markers = Markers( Boundary );
	
	DataReader = New DataReader( Request.GetBodyAsBinaryData() );
	DataReader.SkipTo( Markers );

	Result = New Map();          

	While True Do
	
		Part = DataReader.ReadTo( Markers );
	
		If ( NOT Part.MarkerFound ) Then

			Break;

		EndIf;

		AddByContextType( Result, GetContext(Part) );
	
	EndDo;
	
	Return Result;
	
EndFunction









#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// УстановитьТипКонтента устанавливает в заголовке ответа HTTP-сервиса значение для "Content-Type". 
// 
// Параметры:
// 	Ответ - HTTPСервисОтвет - ответ HTTP-сервиса;
// 	Тип - Строка - тип контента;
//
Процедура УстановитьТипКонтента( Ответ, Знач Тип )
	
	Ответ.Заголовки.Вставить( "Content-Type", Тип );
	
КонецПроцедуры

// УстановитьТелоИзСтрокиJSON устанавливает в теле ответа HTTP-сервиса данные сериализованные в формат JSON.
// 
// Параметры:
// 	Ответ - HTTPСервисОтвет - ответ HTTP-сервиса;
// 	Данные - Структура - данные;
//
Процедура УстановитьТелоИзСтрокиJSON( Ответ, Знач Данные )
	
	Ответ.УстановитьТелоИзСтроки( КоннекторHTTP.ОбъектВJson(Данные) );
	
КонецПроцедуры

// ОтветБезСообщения создает ответ HTTP-сервиса с переданным в метод КодСостояния и без тела сообщения.
// 
// Параметры:
//  КодСостояния - Число - код состояния;
// 
// Возвращаемое значение:
// 	HTTPСервисОтвет - ответ HTTP-сервиса;
//
Функция ОтветБезСообщения( Знач КодСостояния )
	
	Возврат Новый HTTPСервисОтвет( КодСостояния );
	
КонецФункции

#Область Ошибки

// НоваяОшибкаНеправильныйЗапрос создает ответ HTTP-сервиса с кодом статуса 400 (BAD_REQUEST)
// и текстом ошибки в формате JSON в теле ответа.
// 
// Параметры:
// 	Сообщение - Строка - текст ошибки;
// 
// Возвращаемое значение:
// 	HTTPСервисОтвет - ответ HTTP-сервиса;
//
Функция НоваяОшибкаНеправильныйЗапрос( Знач Сообщение )
	
	Ответ = Новый HTTPСервисОтвет( КодыСостояния().НайтиКодПоИдентификатору("BAD_REQUEST") );
	УстановитьТипКонтента( Ответ, "application/json" );
	УстановитьТелоИзСтрокиJSON( Ответ, ПолучитьСхемуСообщения(Сообщение) );
	
	Возврат Ответ;
	
КонецФункции

// НоваяОшибкаЗаблокировано создает ответ HTTP-сервиса с кодом статуса 423 (LOCKED) и текстом причины.
//
// Параметры:
// 	Сообщение - Строка - текст причины;
// 	
// Возвращаемое значение:
// 	HTTPСервисОтвет - ответ HTTP-сервиса;
//
Функция НоваяОшибкаЗаблокировано( Знач Сообщение )
	
	Результат = Новый HTTPСервисОтвет( КодыСостояния().НайтиКодПоИдентификатору("LOCKED") );
	Результат.Причина = Сообщение;
	
	Возврат Результат;

КонецФункции

// НоваяОшибкаСервера создает ответ HTTP-сервиса с кодом статуса 500 (INTERNAL_SERVER_ERROR)
// и текстом ошибки в теле ответа. 
// 
// Параметры:
// 	Сообщение - Строка - текст ошибки;
// 
// Возвращаемое значение:
// 	HTTPСервисОтвет - ответ HTTP-сервиса;
//
Функция НоваяОшибкаСервера( Знач Сообщение )
	
	Результат = Новый HTTPСервисОтвет( КодыСостояния().НайтиКодПоИдентификатору("INTERNAL_SERVER_ERROR") );
	УстановитьТипКонтента( Результат, "text/plain" );
	Результат.УстановитьТелоИзСтроки( Сообщение );
	
	Возврат Результат;

КонецФункции

#КонецОбласти

Function FindBoundary( Val Request )
	
	Var ContentType;
	Var Directives;
	Var Parts;
	
	ContentType = СервисыHTTP.НайтиЗаголовок( Request, "Content-Type" );		
	Directives = StrSplit( ContentType, ";", False );

	For Each Directive In Directives Do
		
		Parts = StrSplit( Directive, "=", False );
		
		If ( TrimAll(Parts[0]) = "boundary" ) Then
			
			Return TrimAll(Parts[1]);
			
		EndIf;

	EndDo;
	
	Return Undefined;
        
EndFunction

Function Markers( Val Boundary )
	
	Var Result;

	Result = New Array();
	Result.Add( Boundary );
	Result.Add( Boundary + Chars.LF );
	Result.Add( Boundary + Chars.CR );
	Result.Add( Boundary + Chars.CR + Chars.LF );
	
	Return Result;
	
EndFunction

Function ReadMultipartHeaders( DataReader )
	
	Var Line;
	Var Parts;
	Var Result;
	
    Result = New Map();
    
    While True Do

		Line = DataReader.ReadLine();
		
		If ( Line = "" ) Then
			
		   Break;
		   
		EndIf;
		
		Parts = StrSplit( Line, ":" );

		Result.Insert( TrimAll(Parts[0]), TrimAll(Parts[1]));
    	
    EndDo;
    
    Return Result;
    
EndFunction

Procedure AddByContextType( Result, Context )
	
	If ( TypeOf(Context) = Type("BinaryData") ) Then
		
		Result.Insert( "BinaryData", Context );
		
	Else
		
		Result.Insert( "String", Context );

	EndIf;
	
EndProcedure

Function GetContext( Part )
	
	Var PartReader;
	
	PartReader = New DataReader( Part.OpenStreamForRead() );

	If ( НайтиЗаголовок(ReadMultipartHeaders(PartReader), "Content-Type") = "application/octet-stream" ) Then
		
		Return PartReader.Read().GetBinaryData();
		
	Else
		
		Return PartReader.ReadChars();

	EndIf;
	
EndFunction






#КонецОбласти
